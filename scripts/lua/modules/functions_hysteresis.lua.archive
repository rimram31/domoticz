package.path = package.path..";/home/pi/domoticz/scripts/lua/modules/?.lua"
require 'functions_utils'

--
-- Hysteresis
--   sensors: list, dz names, of sensors to get temperature, the function take the average
--   thermostat: dummy on/off switch with a planning for confort periods
--   radiators: list, dz names, of radiators/switches to set on/off when needed
--   confort: confirt temperature
--   eco: eco temperature
--   hyst: hysteresis margin
--
function hysteresis(sensors, thermostat, radiators, confort, eco, hyst)
    commands = {}

    time=os.time()
    minutes=tonumber(os.date('%M',time))
    hours=tonumber(os.date('%H',time))

    if (otherdevices[thermostat]=='On') then
        consigne = confort
    else
        consigne = eco
    end
    
    -- Manage a sensor list -> make the average
    local sum = 0
    local count = 0
    for _, sensor in pairs(sensors) do
        sum = sum + tonumber(string.sub(otherdevices_svalues[sensor],1,4))
        count = count + 1
    end
    local temperature = (sum / count)
    	
    if (temperature < (consigne - hyst) ) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='Off' or minutes%15==0) then
                commands[radiator]='On'
    	    end
        end    
    elseif (temperature > (consigne + hyst)) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='On' or minutes%15==0) then
                commands[radiator]='Off'
            end
        end    
    end	
    return commands
    
end

--
-- Hysteresis with multiple confort temperature
--
--  sensors: list, sensors (dz name) to measure temperature, the average is calculated
--  thermostats: array (dict) - the idea is to have a on/off switch for "confort" temperature, having several thermostat
--               with several "confort" temperature allow some exception (I'm using this for bathrooms)
--  radiators: list, radiators (dz name) of switches to set on/off when needed
--  eco: eco temperature
--  hyst: hysteresis margin
--
function hysteresis_final(sensors, thermostats, radiators, eco, hyst)
    commands = {}
    
    time=os.time()
    minutes=tonumber(os.date('%M',time))
    hours=tonumber(os.date('%H',time))
    
    local consigne = eco
    for thermostat,value in pairs(thermostats) do
        if (otherdevices[thermostat]=='On') then
            if (value > consigne) then
                consigne = value
            end
        end
    end
    
    -- Manage a sensor list -> make the average
    local sum = 0
    local count = 0
    for _, sensor in pairs(sensors) do
        sum = sum + tonumber(string.sub(otherdevices_svalues[sensor],1,4))
        count = count + 1
    end
    local temperature = (sum / count)
    
    if (temperature < (consigne - hyst) ) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='Off' or minutes%15==0) then
            --if (otherdevices[radiator]=='Off') then
                commands[radiator]='On'
            end
        end    
    elseif (temperature >= (consigne + hyst)) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='On' or minutes%15==0) then
            --if (otherdevices[radiator]=='On') then
                commands[radiator]='Off'
            end
        end    
    end	
    return commands
    
end

--
-- Hysteresis with multiple confort temperature
--
--  sensors: list, sensors (dz name) to measure temperature, the average is calculated
--  thermostats: array (dict) - the idea is to have a on/off switch for "confort" temperature, having several thermostat
--               with several "confort" temperature allow some exception (I'm using this for bathrooms)
--  radiators: list, radiators (dz name) of switches to set on/off when needed
--  eco: eco temperature
--  hyst: hysteresis margin
--
function hysteresisV2(sensors, thermostats, radiators, present, eco, hyst, resend)
    commands = {}
    
    time=os.time()
    minutes=tonumber(os.date('%M',time))
    hours=tonumber(os.date('%H',time))
    
    local consigne = eco
    if (present == nil or (otherdevices[present]=='On')) then
        for thermostat,value in pairs(thermostats) do
        if (otherdevices[thermostat]=='On') then
            if (value > consigne) then
                consigne = value
            end
        end
        end
    end		
    
    -- Manage a sensor list -> make the average
    local sum = 0
    local count = 0
    for _, sensor in pairs(sensors) do
        sum = sum + tonumber(string.sub(otherdevices_svalues[sensor],1,4))
        count = count + 1
    end
    local temperature = (sum / count)
    
    if (temperature < (consigne - hyst) ) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='Off' or (resend == 0 or minutes%resend==0)) then
            --if (otherdevices[radiator]=='Off') then
                commands[radiator]='On'
            end
        end    
    elseif (temperature >= (consigne + hyst)) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='On' or (resend == 0 or minutes%resend==0)) then
            --if (otherdevices[radiator]=='On') then
                commands[radiator]='Off'
            end
        end    
    end	
    return commands

end

--
-- Hysteresis with multiple confort temperature
--
--  sensors: list, sensors (dz name) to measure temperature, the average is calculated
--  thermostats: array (dict) - the idea is to have a on/off switch for "confort" temperature, having several thermostat
--               with several "confort" temperature allow some exception (I'm using this for bathrooms)
--  radiators: list, radiators (dz name) of switches to set on/off when needed
--  eco: eco temperature
--  hyst: hysteresis margin
--
function hysteresisV3(sensors, thermostats, radiators, active, present, eco, hyst, resend)
    commands = {}
    
    time=os.time()
    minutes=tonumber(os.date('%M',time))
    hours=tonumber(os.date('%H',time))
    
    local consigne = eco
    if (present == nil or (otherdevices[present]=='On')) then
        for thermostat,value in pairs(thermostats) do
        if (otherdevices[thermostat]=='On') then
            if (value > consigne) then
                consigne = value
            end
        end
        end
    end		
    
    -- Manage a sensor list -> make the average
    local sum = 0
    local count = 0
    for _, sensor in pairs(sensors) do
        sum = sum + tonumber(string.sub(otherdevices_svalues[sensor],1,4))
        count = count + 1
    end
    local temperature = (sum / count)
    
    if ( (otherdevices[active]=='On') and (temperature < (consigne - hyst)) ) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='Off' or (resend == 0 or minutes%resend==0)) then
            --if (otherdevices[radiator]=='Off') then
                commands[radiator]='On'
            end
        end    
    elseif ( (otherdevices[active]=='Off') or (temperature >= (consigne + hyst))) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='On' or (resend == 0 or minutes%resend==0)) then
            --if (otherdevices[radiator]=='On') then
                commands[radiator]='Off'
            end
        end    
    end	
    return commands

end

--
-- Hysteresis with multiple confort temperature
--
--  sensors: list, sensors (dz name) to measure temperature, the average is calculated
--  thermostats: array (dict) - the idea is to have a on/off switch for "confort" temperature, having several thermostat
--               with several "confort" temperature allow some exception (I'm using this for bathrooms)
--  radiators: list, radiators (dz name) of switches to set on/off when needed
--  eco: eco temperature
--  hyst: hysteresis margin
--
function hysteresisV4(sensors, thermostats, radiators, active, present, eco, hyst, resend)
    commands = {}
    
    time=os.time()
    minutes=tonumber(os.date('%M',time))
    hours=tonumber(os.date('%H',time))
    
    local consigne = eco
    if (present == nil or (otherdevices[present]=='On')) then
        for thermostat,value in pairs(thermostats) do
        if (otherdevices[thermostat]=='On') then
            if (value > consigne) then
                consigne = value
            end
        end
        end
    end		
    
    -- Manage a sensor list -> make the average
    local sum = 0
    local count = 0
    for _, sensor in pairs(sensors) do
        -- uptodate ? (15mn)
        if (lastupdate(sensor) < 900) then
            sum = sum + tonumber(string.sub(otherdevices_svalues[sensor],1,4))
            count = count + 1
        end
    end
    local temperature = 0
    local disable = true
    if (count > 0) then
        temperature = (sum / count)
        disable = (otherdevices[active]=='Off')
    end

    if ( (not disable) and (temperature < (consigne - hyst)) ) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='Off' or (resend == 0 or minutes%resend==0)) then
            --if (otherdevices[radiator]=='Off') then
                commands[radiator]='On'
            end
        end    
    elseif ((disable) or (temperature >= (consigne + hyst))) then
        for _, radiator in pairs(radiators) do
            if (otherdevices[radiator]=='On' or (resend == 0 or minutes%resend==0)) then
            --if (otherdevices[radiator]=='On') then
                commands[radiator]='Off'
            end
        end    
    end	
    return commands

end
